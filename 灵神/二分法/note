还是按原来的b+1<e然后验证b和e谁是答案比较好，灵神的开区间写法最后不好想明白谁是答案
以前不知道的写法：找大于某个数的第一个数，可以把这个数+1再找call lowerbound方法，既lowerBound(nums, target + 1)  如FindFirstandLastPositionofElementinSortedArray34
对有顺序的矩阵怎么排除不符合条件的数，如KthSmallestNumberinMultiplicationTable668，Searcha2DMatrix74

2080---》就是找上面说的lowerbound，他的二分法b=-1，e=nums。lenght，就用b《e-1的模版，while结束直接返回e就对！
3419---》难，居然是二分法加dfs验证，另外是dijistra的变形，也难
2560---》巩固一下
2576--->关键是怎么写good函数去验证能找到k对匹配的，开始想的是找某个值的第一个大于他的2被的值，是不行的。
669---》即如何算good函数，利用乘法表的性质，第i行的第一个数是x，则这行的所有数都是x的倍数，因此统计有几个小于等于k的数字就是便利每一行，有（x/行）个