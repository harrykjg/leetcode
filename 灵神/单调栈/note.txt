853---》第二轮还是没想明白，记stack里放的是时间
768---》不好想，记stack的size是最后答案，因此看到一个数就和stack的peek比较，大于等于peek就入栈，小于的话就是要融入前一段的数了，
但是要保留stack的top作为最大数，因此要先pop出来第一个数，剩下的如果还是大于当前就都pop出来，最后把最大的再加回来，并且当前数不需要入栈，这个写法不常见
907--->还是很难想，像这种某个数i作为子数组中最小的情况，大概率需要找i往左找第一个小于他的数，和往右找第一个小于他的数，这样即找到了这个i
可以作为最小数的最大范围，那么他贡献了几次就是leftLen*rightLen*arr【i】了
316---》还是不会，思想就是维护一个单调栈，目的就是可以比较当前字符和栈顶元素，如果栈顶大的就pop掉，维持一个尽可能小的顺序，
//但是凭啥可以pop呢，如果pop了之后少了这个字符咋办，因此就要预先统计一下这个将被pop的字符在后面还有没有出现，有的话就可以pop，那么
//如何记录一个字符在某个位置之后还有没有呢，那就用一个map记录出现的次数，遍历到的时候就减减.并且用了单调栈，后面再进来一个已经在栈里的元素
//也不让他进了，比如bcb，遇到第二个b时，用一个set记录他已经出现过了，并且由于是单调栈，说明他第一次出现的时候已经是在字典顺序小的位置了。
//还有一个易错点是遇到栈里有的元素就马上continue，否则他会错误的与栈顶元素比较，如果小于栈顶元素的话就把别人pop掉，是不对的，具体看代码