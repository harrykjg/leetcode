package 灵神.常用数据结构.堆;

public class UglyNumberII264 {
    static void main() {
        System.out.println(nthUglyNumber(10));
    }
    //12/6/2025
    //居然是需要用dp记录前n个丑数，开始以为是2、3、5可以分别乘以1，2，3，4.。。然后他们形成丑数。很明显2*1、3*1、5*1
    //    之中2是最小的，那么2已经用掉了1这个因子了，所以下次只能比2*2、3*1、5*1了。那么直接for loop n次就行了其实不对
    //看回以前的解释，其实不对，其实是已知第一个丑数是1，然后下一个数就是1*2或1*3或1*5.得到丑数【1，2】之后，应该是这现有的丑数
    // 分别乘以2，3，5，而不是说（1，2，3，4，5.。。这个自然数）分别乘以2，3，5。换句话说，假如现在的丑数是1，则下一个数是1*2或3或4中间的最小的，
    //即rs[i1]乘以2和rs【i2】*3和rs【i3】*5中的最小的，而i1，i2，i3初始都是0，因此都是用1去乘以2、3、5、由于rs【i0】*2是最小的，因此i0要
    //加加，意义就是1不能再用来乘以2啦，你只能用丑数的下一位乘以2，也就是说现有丑数才是基数，他们每一个都可以乘以2，3，5，而不是说（1，2
    // 3，4，5这些自然数作为基数去乘以2，3，5）。因此必须要用一个dp[],很容易错
    public static int nthUglyNumber(int n) {
        int i1=0;
        int i2=0;
        int i3=0;
        int[] rs=new int[n];
        rs[0]=1;

        for(int i=1;i<n;i++){
            int min=Math.min(2*rs[i1],Math.min(3*rs[i2],5*rs[i3]));
            rs[i]=min;
            if(2*rs[i1]==min){
                i1++;
            }
            if(3*rs[i2]==min){
                i2++;
            }
            if(5*rs[i3]==min){
                i3++;
            }
        }
        return rs[n-1];
    }
}
